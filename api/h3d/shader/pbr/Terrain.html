<!DOCTYPE html>
<html lang="en"><!-- use theme color or fallback -->
<!--use textcolor from settings, otherwise create a contrasting color to theme color-->
<head><meta charset="utf-8"/><link href="../../../bootstrap/css/bootstrap.min.css" rel="stylesheet"/><link href="../../../bootstrap/css/bootstrap-responsive.min.css" rel="stylesheet"/><link href="../../../bootstrap/css/bootstrap-select.min.css" rel="stylesheet"/><link href="../../../../css/styles.min.css" rel="stylesheet"/><link href="../../../styles.css" rel="stylesheet"/><script type="text/javascript">var dox = {rootPath: "../../../",platforms: ["heaps"]};</script><title>h3d.shader.pbr.Terrain - Heaps.io Game Engine</title><script src="../../../jquery-1.9.1.min.js"></script><script src="../../../bootstrap/js/bootstrap.min.js"></script><script src="../../../bootstrap/js/bootstrap-select.min.js"></script><script type="text/javascript" src="../../../nav.js"></script><script type="text/javascript" src="../../../index.js"></script>   <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:regular,bold,italic,thin,light,bolditalic,black,medium&amp;lang=en"/><link href="https://fonts.googleapis.com/css?family=Roboto|Roboto+Condensed:300" rel="stylesheet"/></head><div class='api-documentation'><body><a href="https://github.com/HeapsIO/" class="fork-button"><img src="../../../../img/fork-on-github.png" alt="Fork Heaps on GitHub"/></a><header class="header-documentation"><nav class="top-nav"><a href="../../../../" class="button">Home</a><a href="../../../../about.html" class="button">About</a><a href="../../../../samples/" class="button">Samples</a><a href="../../../../documentation/" class="button">Documentation</a><a href="../../../" class="button disabled">API</a><a href="https://community.heaps.io/" class="button" target="_blank">Community</a></nav></header><div class="container main-content"><div class="row-fluid"><div class="span3"><div class="well sidebar-nav"><form class="form-search" id="searchForm"><div class="input-prepend input-block-level"><span class="add-on"><i class="icon-search"></i></span><input id="search" type="text" placeholder="Filter (Ctrl+P)" autocomplete="off"/></div></form></div><div class="well sidebar-nav" id="explorer"><div id="nav"></div></div></div><div class="span9"><div class="page-header"><span class="viewsource"><a href="https://github.com/HeapsIO/heaps/blob/master/h3d/shader/pbr/Terrain.hx" class="btn btn-medium"><i class="fa fa-eye"></i> View source</a></span><h1><small>class</small> Terrain</h1><h4><small>package <a href="../../../h3d/shader/pbr/index.html">h3d.shader.pbr</a></small></h4><h4><small>extends <a class="type" title="hxsl.Shader" href="../../../hxsl/Shader.html">Shader</a></small></h4>    <span class="label label-meta label-meta-directlyUsed" title="Marks types that are directly referenced by non-extern code.">@:directlyUsed</span><span class="label label-meta label-meta-src" title="">@:src({
	@:import h3d.shader.BaseMesh;
	@const var SHOW_GRID:Bool;
	@const var SURFACE_COUNT:Int;
	@const var CHECKER:Bool;
	@const var COMPLEXITY:Bool;
	@param var heightMapSize:Float;
	@param var primSize:Float;
	@param var cellSize:Float;
	@param var albedoTextures:Sampler2DArray;
	@param var normalTextures:Sampler2DArray;
	@param var pbrTextures:Sampler2DArray;
	@param var weightTextures:Sampler2DArray;
	@param var surfaceIndexMap:Sampler2D;
	@param var heightMap:Sampler2D;
	@param var surfaceParams:Array&lt;Vec4,SURFACE_COUNT&gt;;
	@param var secondSurfaceParams:Array&lt;Vec4,SURFACE_COUNT&gt;;
	@param var heightBlendStrength:Float;
	@param var heightBlendSharpness:Float;
	@param var parallaxAmount:Float;
	@param var minStep:Int;
	@param var maxStep:Int;
	@param var tileIndex:Vec2;
	var calculatedUV:Vec2;
	var terrainUV:Vec2;
	var TBN:Mat3;
	var emissiveValue:Float;
	var metalnessValue:Float;
	var roughnessValue:Float;
	var occlusionValue:Float;
	function vertex() {
		calculatedUV = input.position.xy / primSize;
		var terrainUV = (calculatedUV * (heightMapSize - 1)) / heightMapSize;
		terrainUV += 0.5 / heightMapSize;
		transformedPosition += (vec3(0, 0, textureLod(heightMap, terrainUV, 0).r) * global.modelView.mat3());
		TBN = mat3(normalize(cross(transformedNormal, vec3(0, 1, 0))), normalize(cross(transformedNormal, vec3(-1, 0, 0))), transformedNormal);
	};
	function getPOMUV(uv:Vec2, surfaceIndex:Int):Vec2 {
		var viewWS = (camera.position - transformedPosition).normalize();
		var viewNS:Vec3;
		{
			var n = transformedNormal.normalize();
			var transformedTangent = normalize(cross(transformedNormal, vec3(0, 1, 0)));
			var tanX = transformedTangent.xyz.normalize();
			var tanY = n.cross(tanX);
			viewNS = vec3(viewWS.dot(tanX), viewWS.dot(tanY), viewWS.dot(n)).normalize();
		};
		var numLayers = mix(float(maxStep), float(minStep), abs(viewNS.z));
		var layerDepth = 1 / numLayers;
		var curLayerDepth = 0.;
		var delta = (viewNS.xy / viewNS.z) * parallaxAmount / numLayers * 1.0 / surfaceParams[surfaceIndex].x;
		var curUV = uv;
		var curDepth = 1 - pbrTextures.get(getsurfaceUV(surfaceIndex, curUV)).a;
		while (curLayerDepth &lt; curDepth) {
			curUV += delta;
			curDepth = 1 - pbrTextures.getLod(getsurfaceUV(surfaceIndex, curUV), 0).a;
			curLayerDepth += layerDepth;
		};
		var prevUV = curUV - delta;
		var after = curDepth - curLayerDepth;
		var before = (1 - pbrTextures.get(vec3(prevUV, surfaceIndex)).a) - curLayerDepth + layerDepth;
		return mix(curUV, prevUV, after / (after - before));
	};
	function getsurfaceUV(i:Int, uv:Vec2):Vec3 {
		var angle = surfaceParams[i].w;
		var offset = vec2(surfaceParams[i].y, surfaceParams[i].z);
		var tilling = surfaceParams[i].x;
		var worldUV = vec2((uv + tileIndex) * tilling) + offset;
		var res = vec2(worldUV.x * cos(angle) - worldUV.y * sin(angle), worldUV.y * cos(angle) + worldUV.x * sin(angle));
		var surfaceUV = vec3(res, i);
		return surfaceUV;
	};
	function fragment() {
		var texIndex = surfaceIndexMap.get(calculatedUV).rgb;
		var i1:Int = int(texIndex.r * 255);
		var uv1 = getPOMUV(calculatedUV, i1);
		var surfaceUV1 = getsurfaceUV(i1, uv1);
		var pbr1 = pbrTextures.get(surfaceUV1).rgba;
		var albedo1 = albedoTextures.get(surfaceUV1).rgb;
		var normal1 = normalTextures.get(surfaceUV1).rgba;
		var h1 = pbr1.a;
		var aw1 = weightTextures.get(vec3(calculatedUV, i1)).r;
		var i2:Int = int(texIndex.g * 255);
		var aw2 = weightTextures.get(vec3(calculatedUV, i2)).r;
		var i3:Int = int(texIndex.b * 255);
		var aw3 = weightTextures.get(vec3(calculatedUV, i3)).r;
		var albedo = vec3(0);
		var normal = vec4(0, 0, 0, 0);
		var pbr = vec4(0);
		var weightSum = 0.0;
		var maxAlbedo = vec3(0);
		var maxPbr = vec4(0);
		var maxNormal = vec4(0);
		var curMaxWeight = -1.0;
		var b1 = 0.0, b2 = 0.0, b3 = 0.0;
		b1 = mix(aw1, aw1 * h1, heightBlendStrength);
		albedo += albedo1 * b1;
		pbr += pbr1 * b1;
		normal += normal1 * b1;
		var maxW = clamp(ceil(b1 - curMaxWeight), 0, 1);
		curMaxWeight = mix(curMaxWeight, b1, maxW);
		maxAlbedo = mix(maxAlbedo, albedo1, maxW);
		maxPbr = mix(maxPbr, pbr1, maxW);
		maxNormal = mix(maxNormal, normal1, maxW);
		if (aw2 &gt; 0) {
			var uv2 = getPOMUV(calculatedUV, i2);
			var surfaceUV2 = getsurfaceUV(i2, uv2);
			var pbr2 = pbrTextures.get(surfaceUV2).rgba;
			var albedo2 = albedoTextures.get(surfaceUV2).rgb;
			var normal2 = normalTextures.get(surfaceUV2).rgba;
			var h2 = pbr2.a;
			b2 = mix(aw2, aw2 * h2, heightBlendStrength);
			albedo += albedo2 * b2;
			pbr += pbr2 * b2;
			normal += normal2 * b2;
			maxW = clamp(ceil(b2 - curMaxWeight), 0, 1);
			curMaxWeight = mix(curMaxWeight, b2, maxW);
			maxAlbedo = mix(maxAlbedo, albedo2, maxW);
			maxPbr = mix(maxPbr, pbr2, maxW);
			maxNormal = mix(maxNormal, normal2, maxW);
		};
		if (aw3 &gt; 0) {
			var uv3 = getPOMUV(calculatedUV, i3);
			var surfaceUV3 = getsurfaceUV(i3, uv3);
			var pbr3 = pbrTextures.get(surfaceUV3).rgba;
			var albedo3 = albedoTextures.get(surfaceUV3).rgb;
			var normal3 = normalTextures.get(surfaceUV3).rgba;
			var h3 = pbr3.a;
			b3 = mix(aw3, aw3 * h3, heightBlendStrength);
			albedo += albedo3 * b3;
			pbr += pbr3 * b3;
			normal += normal3 * b3;
			maxW = clamp(ceil(b3 - curMaxWeight), 0, 1);
			curMaxWeight = mix(curMaxWeight, b3, maxW);
			maxAlbedo = mix(maxAlbedo, albedo3, maxW);
			maxPbr = mix(maxPbr, pbr3, maxW);
			maxNormal = mix(maxNormal, normal3, maxW);
		};
		weightSum = b1 + b2 + b3;
		albedo /= vec3(weightSum);
		pbr /= vec4(weightSum);
		normal /= vec4(weightSum);
		albedo = mix(albedo, maxAlbedo, heightBlendSharpness);
		pbr = mix(pbr, maxPbr, heightBlendSharpness);
		normal = mix(normal, maxNormal, heightBlendSharpness);
		normal = vec4(unpackNormal(normal), 0.0);
		pixelColor = vec4(albedo, 1.0);
		transformedNormal = normalize(normal.xyz) * TBN;
		roughnessValue = 1 - pbr.g * pbr.g;
		metalnessValue = pbr.r;
		occlusionValue = pbr.b;
		emissiveValue = 0;
		if (CHECKER) {
			var tile = abs(abs(floor(input.position.x)) % 2 - abs(floor(input.position.y)) % 2);
			pixelColor = vec4(mix(vec3(0.4), vec3(0.1), tile), 1.0);
			transformedNormal = vec3(0, 0, 1) * TBN;
			roughnessValue = mix(0.9, 0.6, tile);
			metalnessValue = mix(0.4, 0, tile);
			occlusionValue = 1;
			emissiveValue = 0;
		} else if (COMPLEXITY) {
			var blendCount = 0 + weightTextures.get(vec3(0)).r * 0;
			for (i in 0 ... SURFACE_COUNT) blendCount += ceil(weightTextures.get(vec3(calculatedUV, i)).r);
			pixelColor = vec4(mix(vec3(0, 1, 0), vec3(1, 0, 0), blendCount / 3.0), 1);
			transformedNormal = vec3(0, 0, 1) * TBN;
			emissiveValue = 1;
			roughnessValue = 1;
			metalnessValue = 0;
			occlusionValue = 1;
		};
		if (SHOW_GRID) {
			var gridColor = vec4(1, 0, 0, 1);
			var tileEdgeColor = vec4(1, 1, 0, 1);
			var grid:Vec2 = ((input.position.xy.mod(cellSize) / cellSize) - 0.5) * 2.0;
			grid = ceil(max(vec2(0), abs(grid) - 0.9));
			var tileEdge = max((1 - ceil(input.position.xy / primSize - 0.1 / (primSize / cellSize))), floor(input.position.xy / primSize + 0.1 / (primSize / cellSize)));
			emissiveValue = max(max(grid.x, grid.y), max(tileEdge.x, tileEdge.y));
			pixelColor = mix(pixelColor, gridColor, clamp(0, 1, max(grid.x, grid.y)));
			pixelColor = mix(pixelColor, tileEdgeColor, clamp(0, 1, max(tileEdge.x, tileEdge.y)));
			metalnessValue = mix(metalnessValue, 0, emissiveValue);
			roughnessValue = mix(roughnessValue, 1, emissiveValue);
			occlusionValue = mix(occlusionValue, 1, emissiveValue);
			transformedNormal = mix(transformedNormal, vec3(0, 1, 0), emissiveValue);
		};
	};
})</span><span class="label label-meta label-meta-build" title="Builds a class or enum from a macro.">@:build(hxsl.Macros.buildShader())</span><span class="label label-meta label-meta-autoBuild" title="Extends `@:build` metadata to all extending and implementing classes.">@:autoBuild(hxsl.Macros.buildShader())</span></div><div class="body"><div class="doc doc-main"><p></p></div><h3 class="section">Constructor</h3><div class="fields"><div class="field "><a name="new"></a><h3 class="anchor"><code><a href="#new"><span class="identifier">new</span></a>()</code></h3><div class="doc"><p></p></div></div></div><h3 class="section">Variables</h3><div class="fields"><div class="field "><a name="CHECKER"></a><h3 class="anchor"><code><a href="#CHECKER"><span class="identifier">CHECKER</span></a>:<span class="type">Bool</span></code></h3><div class="doc"><p></p></div></div><div class="field "><a name="COMPLEXITY"></a><h3 class="anchor"><code><a href="#COMPLEXITY"><span class="identifier">COMPLEXITY</span></a>:<span class="type">Bool</span></code></h3><div class="doc"><p></p></div></div><div class="field "><a name="SHOW_GRID"></a><h3 class="anchor"><code><a href="#SHOW_GRID"><span class="identifier">SHOW_GRID</span></a>:<span class="type">Bool</span></code></h3><div class="doc"><p></p></div></div><div class="field "><a name="SURFACE_COUNT"></a><h3 class="anchor"><code><a href="#SURFACE_COUNT"><span class="identifier">SURFACE_COUNT</span></a>:<span class="type">Int</span></code></h3><div class="doc"><p></p></div></div><div class="field "><a name="albedoTextures"></a><h3 class="anchor"><code><a href="#albedoTextures"><span class="identifier">albedoTextures</span></a>:<a class="type" title="hxsl.Sampler2DArray" href="../../../hxsl/Sampler2DArray.html">Sampler2DArray</a></code></h3><div class="doc"><p></p></div></div><div class="field "><a name="cellSize"></a><h3 class="anchor"><code><a href="#cellSize"><span class="identifier">cellSize</span></a>:<span class="type">Float</span></code></h3><div class="doc"><p></p></div></div><div class="field "><a name="heightBlendSharpness"></a><h3 class="anchor"><code><a href="#heightBlendSharpness"><span class="identifier">heightBlendSharpness</span></a>:<span class="type">Float</span></code></h3><div class="doc"><p></p></div></div><div class="field "><a name="heightBlendStrength"></a><h3 class="anchor"><code><a href="#heightBlendStrength"><span class="identifier">heightBlendStrength</span></a>:<span class="type">Float</span></code></h3><div class="doc"><p></p></div></div><div class="field "><a name="heightMap"></a><h3 class="anchor"><code><a href="#heightMap"><span class="identifier">heightMap</span></a>:<a class="type" title="hxsl.Sampler2D" href="../../../hxsl/Sampler2D.html">Sampler2D</a></code></h3><div class="doc"><p></p></div></div><div class="field "><a name="heightMapSize"></a><h3 class="anchor"><code><a href="#heightMapSize"><span class="identifier">heightMapSize</span></a>:<span class="type">Float</span></code></h3><div class="doc"><p></p></div></div><div class="field "><a name="maxStep"></a><h3 class="anchor"><code><a href="#maxStep"><span class="identifier">maxStep</span></a>:<span class="type">Int</span></code></h3><div class="doc"><p></p></div></div><div class="field "><a name="minStep"></a><h3 class="anchor"><code><a href="#minStep"><span class="identifier">minStep</span></a>:<span class="type">Int</span></code></h3><div class="doc"><p></p></div></div><div class="field "><a name="normalTextures"></a><h3 class="anchor"><code><a href="#normalTextures"><span class="identifier">normalTextures</span></a>:<a class="type" title="hxsl.Sampler2DArray" href="../../../hxsl/Sampler2DArray.html">Sampler2DArray</a></code></h3><div class="doc"><p></p></div></div><div class="field "><a name="parallaxAmount"></a><h3 class="anchor"><code><a href="#parallaxAmount"><span class="identifier">parallaxAmount</span></a>:<span class="type">Float</span></code></h3><div class="doc"><p></p></div></div><div class="field "><a name="pbrTextures"></a><h3 class="anchor"><code><a href="#pbrTextures"><span class="identifier">pbrTextures</span></a>:<a class="type" title="hxsl.Sampler2DArray" href="../../../hxsl/Sampler2DArray.html">Sampler2DArray</a></code></h3><div class="doc"><p></p></div></div><div class="field "><a name="primSize"></a><h3 class="anchor"><code><a href="#primSize"><span class="identifier">primSize</span></a>:<span class="type">Float</span></code></h3><div class="doc"><p></p></div></div><div class="field "><a name="secondSurfaceParams"></a><h3 class="anchor"><code><a href="#secondSurfaceParams"><span class="identifier">secondSurfaceParams</span></a>:<span class="type">Array</span>&lt;<a class="type" title="hxsl.Vec" href="../../../hxsl/Vec.html">Vec</a>&gt;</code></h3><div class="doc"><p></p></div></div><div class="field "><a name="surfaceIndexMap"></a><h3 class="anchor"><code><a href="#surfaceIndexMap"><span class="identifier">surfaceIndexMap</span></a>:<a class="type" title="hxsl.Sampler2D" href="../../../hxsl/Sampler2D.html">Sampler2D</a></code></h3><div class="doc"><p></p></div></div><div class="field "><a name="surfaceParams"></a><h3 class="anchor"><code><a href="#surfaceParams"><span class="identifier">surfaceParams</span></a>:<span class="type">Array</span>&lt;<a class="type" title="hxsl.Vec" href="../../../hxsl/Vec.html">Vec</a>&gt;</code></h3><div class="doc"><p></p></div></div><div class="field "><a name="tileIndex"></a><h3 class="anchor"><code><a href="#tileIndex"><span class="identifier">tileIndex</span></a>:<a class="type" title="hxsl.Vec" href="../../../hxsl/Vec.html">Vec</a></code></h3><div class="doc"><p></p></div></div><div class="field "><a name="weightTextures"></a><h3 class="anchor"><code><a href="#weightTextures"><span class="identifier">weightTextures</span></a>:<a class="type" title="hxsl.Sampler2DArray" href="../../../hxsl/Sampler2DArray.html">Sampler2DArray</a></code></h3><div class="doc"><p></p></div></div></div><h3 class="section">Methods</h3><div class="fields"></div>  <div class="inherited-fields well"><h3 class="section">Inherited Variables</h3><div class="fields"><h4><a href="#" class="expand-button"><i class="fa fa-arrow-circle-o-right"></i></a> Defined by <a class="type" title="hxsl.Shader" href="../../../hxsl/Shader.html">Shader</a></h4><div style="display:none"><div class="field "><a name="priority"></a><h3 class="anchor"><code><span class="label">read only</span><a href="#priority"><span class="identifier">priority</span></a>:<span class="type">Int</span></code></h3><div class="doc"><p></p></div></div></div></div><h3 class="section">Inherited Methods</h3><div class="fields"><h4><a href="#" class="expand-button"><i class="fa fa-arrow-circle-o-right"></i></a> Defined by <a class="type" title="hxsl.Shader" href="../../../hxsl/Shader.html">Shader</a></h4><div style="display:none"><div class="field "><a name="setPriority"></a><h3 class="anchor"><code><a href="#setPriority"><span class="identifier">setPriority</span></a>(<span style="white-space:nowrap">v:<span class="type">Int</span></span>):<span class="type">Void</span></code></h3><div class="doc"><p>Shader priority should only be changed <em>before</em> the shader is added to a material.</p></div></div><div class="field "><a name="toString"></a><h3 class="anchor"><code><a href="#toString"><span class="identifier">toString</span></a>():<span class="type">String</span></code></h3><div class="doc"><p></p></div></div></div></div></div></div></div></div></div><footer><div class="container row"><div class="col-5"><a href="../../../../"><img src="../../../../img/logo.svg"/></a></div><div class="col-3 links"><h3>Heaps.io</h3><p>Heaps is an open source and multi-platform toolkit to create 2D and 3D games.</p><a href="https://lib.haxe.org/p/heaps">Download</a><a href="../../../../about.html">About</a><a href="../../../../api">API</a><a href="https://github.com/HeapsIO/">Contribute</a><a href="https://discordapp.com/channels/162395145352904705/501408700142059520">Community</a></div><div class="col-1">&nbsp;</div><div class="col-3 links"><h3>Haxe</h3><p>Haxe is an open source and cross-platform language and toolkit.</p><a href="https://haxe.org">About</a><a href="https://haxe.org/use-cases">Use cases</a><a href="https://haxe.org/documentation/introduction/">Learn</a><a href="https://haxe.org/foundation">Haxe Foundation</a></div></div><div class="copyright">&copy; 2020 <a href="https://haxe.org/foundation/">Haxe Foundation</a>| <a href="https://github.com/HeapsIO/heaps/blob/master/h3d/shader/pbr/Terrain.hx">Contribute to this page</a>| <a href="https://feathericons.com/" rel="nofollow">Feather open source icons</a></div></footer></div><script async="async" defer="defer" src="https://buttons.github.io/buttons.js"></script><script src="../../..//highlighter.js"></script><link href="../../../highlighter.css" rel="stylesheet"/></body></html>